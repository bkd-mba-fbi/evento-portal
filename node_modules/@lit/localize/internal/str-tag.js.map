{"version":3,"file":"str-tag.js","sourceRoot":"","sources":["../src/internal/str-tag.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAUH;;;;;;;;;;;GAWG;AACH,MAAM,IAAI,GAAG,CACX,OAA6B,EAC7B,GAAG,MAAiB,EACT,EAAE,CAAC,CAAC;IACf,MAAM,EAAE,IAAI;IACZ,OAAO;IACP,MAAM;CACP,CAAC,CAAC;AAEH,MAAM,CAAC,MAAM,GAAG,GAA+C,IAAI,CAAC;AAEpE,MAAM,CAAC,MAAM,WAAW,GAAG,CAAC,GAAiB,EAAoB,EAAE,CACjE,OAAO,GAAG,KAAK,QAAQ,IAAI,QAAQ,IAAI,GAAG,CAAC;AAE7C;;;GAGG;AACH,MAAM,CAAC,MAAM,oBAAoB,GAAG,CAClC,OAA6B,EAC7B,MAA2B,EAC3B,UAAqB,EACrB,EAAE;IACF,IAAI,MAAM,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;IACxB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACvC,MAAM,IAAI,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;QACzD,MAAM,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC;KACtB;IACD,OAAO,MAAM,CAAC;AAChB,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport type {TemplateLike} from './types';\n\nexport interface StrResult {\n  strTag: true;\n  strings: TemplateStringsArray;\n  values: unknown[];\n}\n\n/**\n * Tag that allows expressions to be used in localized non-HTML template\n * strings.\n *\n * Example: msg(str`Hello ${this.user}!`);\n *\n * The Lit html tag can also be used for this purpose, but HTML will need to be\n * escaped, and there is a small overhead for HTML parsing.\n *\n * Untagged template strings with expressions aren't supported by lit-localize\n * because they don't allow for values to be captured at runtime.\n */\nconst _str = (\n  strings: TemplateStringsArray,\n  ...values: unknown[]\n): StrResult => ({\n  strTag: true,\n  strings,\n  values,\n});\n\nexport const str: typeof _str & {_LIT_LOCALIZE_STR_?: never} = _str;\n\nexport const isStrTagged = (val: TemplateLike): val is StrResult =>\n  typeof val !== 'string' && 'strTag' in val;\n\n/**\n * Render the result of a `str` tagged template to a string. Note we don't need\n * to do this for Lit templates, since Lit itself handles rendering.\n */\nexport const joinStringsAndValues = (\n  strings: TemplateStringsArray,\n  values: Readonly<unknown[]>,\n  valueOrder?: number[]\n) => {\n  let concat = strings[0];\n  for (let i = 1; i < strings.length; i++) {\n    concat += values[valueOrder ? valueOrder[i - 1] : i - 1];\n    concat += strings[i];\n  }\n  return concat;\n};\n"]}