{"version":3,"file":"runtime-msg.js","sourceRoot":"","sources":["../src/internal/runtime-msg.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAC,UAAU,EAAC,MAAM,kBAAkB,CAAC;AAC5C,OAAO,EAAC,oBAAoB,EAAC,MAAM,cAAc,CAAC;AAClD,OAAO,EAAC,aAAa,EAAC,MAAM,oBAAoB,CAAC;AAKjD,MAAM,gBAAgB,GAAG,IAAI,OAAO,EAA4B,CAAC;AACjE,MAAM,SAAS,GAAG,IAAI,GAAG,EAAyC,CAAC;AAEnE,MAAM,UAAU,UAAU,CACxB,SAAkC,EAClC,QAAsB,EACtB,OAA+B;;IAE/B,IAAI,SAAS,EAAE;QACb,MAAM,EAAE,GAAG,MAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,EAAE,mCAAI,UAAU,CAAC,QAAQ,CAAC,CAAC;QAC/C,MAAM,SAAS,GAAG,SAAS,CAAC,EAAE,CAAC,CAAC;QAChC,IAAI,SAAS,EAAE;YACb,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE;gBACjC,sBAAsB;gBACtB,OAAO,SAAS,CAAC;aAClB;iBAAM,IAAI,QAAQ,IAAI,SAAS,EAAE;gBAChC,2BAA2B;gBAC3B,EAAE;gBACF,+DAA+D;gBAC/D,iEAAiE;gBACjE,sEAAsE;gBACtE,sEAAsE;gBACtE,oDAAoD;gBACpD,OAAO,oBAAoB,CACzB,SAAS,CAAC,OAAO;gBACjB,sEAAsE;gBACtE,oDAAoD;gBACnD,QAA2B,CAAC,MAAM,EACnC,SAAS,CAAC,MAAkB,CAC7B,CAAC;aACH;iBAAM;gBACL,mCAAmC;gBACnC,EAAE;gBACF,uEAAuE;gBACvE,uEAAuE;gBACvE,sBAAsB;gBACtB,IAAI,KAAK,GAAG,gBAAgB,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;gBAC5C,IAAI,KAAK,KAAK,SAAS,EAAE;oBACvB,KAAK,GAAG,SAAS,CAAC,MAAkB,CAAC;oBACrC,gBAAgB,CAAC,GAAG,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;iBACxC;gBACD,OAAO;oBACL,GAAG,SAAS;oBACZ,MAAM,EAAE,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAE,QAA2B,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;iBACjE,CAAC;aACH;SACF;KACF;IACD,OAAO,UAAU,CAAC,QAAQ,CAAC,CAAC;AAC9B,CAAC;AAED,SAAS,UAAU,CAAC,QAAsB;IACxC,MAAM,OAAO,GAAG,OAAO,QAAQ,KAAK,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC;IAC3E,IAAI,EAAE,GAAG,SAAS,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;IAChC,IAAI,EAAE,KAAK,SAAS,EAAE;QACpB,EAAE,GAAG,aAAa,CAChB,OAAO,EACP,OAAO,QAAQ,KAAK,QAAQ,IAAI,CAAC,CAAC,QAAQ,IAAI,QAAQ,CAAC,CACxD,CAAC;QACF,SAAS,CAAC,GAAG,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC;KAC5B;IACD,OAAO,EAAE,CAAC;AACZ,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {defaultMsg} from './default-msg.js';\nimport {joinStringsAndValues} from './str-tag.js';\nimport {generateMsgId} from './id-generation.js';\n\nimport type {TemplateLike, MsgOptions, TemplateMap} from './types.js';\nimport type {TemplateResult} from 'lit';\n\nconst expressionOrders = new WeakMap<TemplateResult, number[]>();\nconst hashCache = new Map<TemplateStringsArray | string, string>();\n\nexport function runtimeMsg(\n  templates: TemplateMap | undefined,\n  template: TemplateLike,\n  options: MsgOptions | undefined\n): string | TemplateResult {\n  if (templates) {\n    const id = options?.id ?? generateId(template);\n    const localized = templates[id];\n    if (localized) {\n      if (typeof localized === 'string') {\n        // E.g. \"Hello World!\"\n        return localized;\n      } else if ('strTag' in localized) {\n        // E.g. str`Hello ${name}!`\n        //\n        // Localized templates have ${number} in place of real template\n        // expressions. They can't have real template values, because the\n        // variable scope would be wrong. The number tells us the index of the\n        // source value to substitute in its place, because expressions can be\n        // moved to a different position during translation.\n        return joinStringsAndValues(\n          localized.strings,\n          // Cast `template` because its type wasn't automatically narrowed (but\n          // we know it must be the same type as `localized`).\n          (template as TemplateResult).values,\n          localized.values as number[]\n        );\n      } else {\n        // E.g. html`Hello <b>${name}</b>!`\n        //\n        // We have to keep our own mapping of expression ordering because we do\n        // an in-place update of `values`, and otherwise we'd lose ordering for\n        // subsequent renders.\n        let order = expressionOrders.get(localized);\n        if (order === undefined) {\n          order = localized.values as number[];\n          expressionOrders.set(localized, order);\n        }\n        return {\n          ...localized,\n          values: order.map((i) => (template as TemplateResult).values[i]),\n        };\n      }\n    }\n  }\n  return defaultMsg(template);\n}\n\nfunction generateId(template: TemplateLike): string {\n  const strings = typeof template === 'string' ? template : template.strings;\n  let id = hashCache.get(strings);\n  if (id === undefined) {\n    id = generateMsgId(\n      strings,\n      typeof template !== 'string' && !('strTag' in template)\n    );\n    hashCache.set(strings, id);\n  }\n  return id;\n}\n"]}